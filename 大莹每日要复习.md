# ==Java基础==

## Comparable和Comparator区别

Comparable和Comparator都是接口

Comparable对实现它的每个类的对象进行整体的排序，如果在创建一个类时，如果这个具有排序的属性，那么最好去实现这个comparable接口，并override他的CompareTo方法。

Comparator是比较器，如果一个类已经没法修改了，那么可以采用外部比较器Comparator, override它的compare方法。



## Java方法的参数传递

java编程语言只有值传递参数。

如果参数类型是基本数据类型，那么传递值的副本，在函数中改变副本的值不回改变原始的值。

如果参数类型是饮用类型，那么传递的是这个引用参数的副本，副本存放的是参数的地址。

- 如果在方法内修改了地址指向的内容，那么就会影响传入地址的内容（这里是浅拷贝）
- 如果在方法内new了一个新的指向，副本指向新的内容，那么副本的修改不回改变原地址的内容。（深拷贝）



## 深拷贝和浅拷贝

区别：如果在拷贝这个对象的时候，只对基本数据类型进行了拷贝，而对引用数据类型只是进行了引用的传递，而没有真实的创建一个新的对象，则认为是**浅拷贝**。如果在引用数据类型进行拷贝的时候，创建了一个新的对象，并且复制其内的成员变量，则认为是**深拷贝**。

clone()方法是对当前对象进行浅拷贝。

如何进行深拷贝：

- 序列化这个对象，在反序列化回来，就可以得到这个新的对象。
- 继续利用clone()方法。



## 什么是 java 序列化？什么情况下需要序列化？

序列化：将 Java 对象转换成字节流的过程。

反序列化：将字节流转换成 Java 对象的过程。

当 Java 对象需要**在网络上传输**或者**持久化存储到文件中**时，就需要对 Java 对象进行序列化处理。

序列化的实现：类实现 Serializable 接口，这个接口没有需要实现的方法。实现 Serializable 接口是为了告诉 jvm 这个类的对象可以被序列化。

注意事项：

- 某个类可以被序列化，则其子类也可以被序列化
- 声明为 static 和 transient 的成员变量，不能被序列化。static 成员变量是描述类级别的属性，transient 表示临时数据
- 反序列化读取序列化对象的顺序要保持一致



## Java重载和重写的区别

Java三大特性：继承，封装，多态

重载和重写都是多态的体现：

**重载**：同一类中同名函数，具有不同参数个数或类型（返回值不参与），是一个类中多态性的体现。

**重写**：子类中含有与父类相同名字、返回类型和参数表，则为重写。



## Java中“==”和equals区别

- **“==”**：如果是基本数据类型，直接对值进行比较，如果是引用数据类型，则是对他们的地址进行比较。
- **equals**: 方法继承自Object类，在具体是现实可以覆盖父类的实现。由equals源码可知，它的本质实现也是对对象的地址进行比较，本质就是“==”。在JDK类中有一些类覆盖了equals()方法，比较规则为如果两个对象的类型一致，并且内容一致，则返回true，这些类有（String, file，Date,包装类有Integer，Double等）
  1. 类未复写equals方法，则使用equals方法比较两个对象时，相当于==比较，即两个对象的地址是否相等，地址相等，返回true，地址不想等，返回false。
  2. 类复写equals方法，比较两个对象时，则走复写之后的判断方式。通常会复写为：当两个对象的内容相同时，则equals返回true，内容不同时，则返回false.



## hashCode（）与equals（）

**hashCode()** 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。

首先最重要的是`hashCode()`相等并不表示对象相等，`equals()`为`true`则对象一定相等，且Java要求此时的计算出的`hashCode()`必须一致。**所以实际上的判断对象是否相等是先判断`hashCode()`是否相等，如果不相等则对象肯定不相等，如果相等则继续调用`equals()`判断对象是否相等。**



## Object类有哪些方法？

`getClass()`：这是一个`final`方法。其作用是获取对象的运行时`Class`。

`hashCode()`：获取对象的哈希值，一般情况下是根据对象的地址或者字符串或者数字计算。

`equals()`：判断两个对象是否相等。

`clone()`：这是一个`protected`方法。实现对象的浅复制，只有当对象实现了`Cloneable`接口才可以调用该方法，否则抛出`CloneNotSupportedException`异常。

`toString()`：返回一个能够表示该对象的字符串，一般来说该字符串应该是简明而有意义的，且尽量所有的子类都应该重写该方法。

`notify()`：唤醒在该对象上等待的某个线程，如果有多个线程在该对象上等待，那么按照一定的算法唤醒其中一个。

`notifyAll()`：唤醒在该对象上等待的所有线程

`wait()`：使当前线程等待该对象上的锁。

`finalize()`：这是一个`protected`方法。在垃圾回收时一定会被执行，当对象被释放时，该方法则会被调用进而程序员可通过该方法释放JVM无法管理的内存以避免内存泄漏。



## static关键字的作用

1. 修饰变量：因为类加载进方法区，所以多个对象时共享的。
2. 修饰方法：工具类的方法，不需要建立对象，直接使用“类名.方法名”的方式调用。
3. 修饰静态代码块：只会在类被初次加载的时候执行一次，可以用于初始化等操作。
4. 静态内部类

PS：一般方法可以访问静态方法的，但是静态的必须访问静态的。



## 抽象类和接口的区别

**抽象类**（为了继承而存在）：

如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。

	1. 抽象方法必须是public或者protected(因为如果是private，则不能被子类继承，子类便无法实现该方法)，缺省情况下默认为public。
 	2. 抽象类不能用来创建对象
 	3. 如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract。

**接口**（更为抽象）：

在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。

	1. 变量只能定义为public static final
 	2. 方法只能为抽象的

**区别**：

1. 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract方法
2. 抽象类中的成员变量可以是各种类型，而接口中的成员变量只能是public static final类型的
3. 接口中不能含有静态代码块和静态方法，而抽象类可以有
4. 一个类只能继承一个抽象类，而一个类可以实现多个接口
5. 抽象类作为很多子类的父类，是一种模版式设计，而接口是一种行为规范，它是一种辐射式设计。



## HashMap底层数据结构

HashMap采用数组+链表实现，HashMap是一个用于存储Key-Value键值对的集合，每一个键值对也叫做Node。这些个键值对（Node）分散存储在一个数组当中，这个数组就是HashMap的主干，实际上它的每一个元素都是链表，当添加一个元素（key-value）时，就首先计算元素key的hash值，以此确定插入数组中的位置index，但是可能存在同一hash值的元素已经被放在数组同一位置了，这时就添加到同一hash值的元素的后面，他们在数组的同一位置，但是形成了链表，所以说数组存放的是链表。新来的Entry节点插入链表时，使用的是“头插法”，因为HashMap的发明者认为，后插入Entry被查找的可能性更大。当链表长度超过8时,就转为红黑树,红黑树的增删改查较快,就提高了hashmap的性能，这样大大提高了查找的效率。



## HashMap的哈希函数如何实现？还有哪些hash实现方式？

h = key.hashCode()^(h>>16)高16bit不变，低16bit和高16bit做异或获得hash值，然后(n-1)&hash获得下标。

hash实现方式：

- 直接定址法
- 数字分析法
- 除留余数法
- 分段叠加法
- 平方取中法
- 伪随机数法



## 为什么HashMap中的&位必须为奇数（length-1）

长度为16或者其他2的幂，length-1的值是所有二进制位全为1，这种情况下，index的结果等同于HashCode后几位的值。只要输入的HashCode本身分布均匀，Hash算法的结果就是均匀的。然后使用length-1&hashcode，相当于求出余数，比%快的。



## 如何解决Hash冲突？

HashMap的冲突解决是用的链地址法，将所以哈希地址相同的记录都链接在同一链表中。

还有其他办法：开放地址（外加增量d）、再哈希法（hash函数不同）、链地址法、建立公共溢出区。



## HashMap线程并发安全性问题

两方面：

1. 如果多个线程同时使用put方法添加元素，而且假设正好存在两个 put 的 key 发生了碰撞，那么根据HashMap的实现，这两个key会添加到数组的同一个位置，这样最终就会发生其中一个线程put的数据被覆盖。
2. 如果多个线程同时检测到元素个数超过数组大小*loadFactor，这样就会发生多个线程同时对Node数组进行扩容，都在重新计算元素位置以及复制数据，但是最终只有一个线程扩容后的数组会给table， 也就是其他线程的都会丢失，并且各自线程put的数据也丢失。



## 红黑树的特征

红黑树本质上是平衡查找二叉树，用于存储有序数据，相对于链表数据查找来说，链表的时间复杂度`O(n)`，红黑树的时间复杂度`O(logn)`。

红黑树需要满足一下五种特性：

- 每个节点是红色或者黑色
- 根节点是黑色
- 每一个空叶子节点必须是黑色
- 红色节点的子节点必须是黑色
- 节点中到达任意子节点包含相同数组的黑节点

当新增节点或者减少节点，红黑树会通过左旋或者右旋操作来调整树结构，使其满足以上特性。



## AVL数和红黑树

它又叫AVL树，平衡二叉树要求对于每一个节点来说，它的左右子树的高度之差不能超过1，如果插入或者删除一个节点使得高度之差大于1，就要进行节点之间的旋转，将二叉树重新维持在一个平衡状态。这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。


- 平衡树（AVL）是为了解决 二叉查找树（BST）退化为链表的情况。
- 红黑树（RBT）是为了解决 平衡树 在删除等操作需要频繁调整的情况。



## HashMap, LinkedHashMap, TreeMap底层区别

LinkedHashMap 拥有HashMap的所有特性，它比HashMap多维护了一个双向链表，因此可以按照插入的顺序从头部或者从尾部迭代，是有序的，不过因为比HashMap多维护了一个双向链表，它的内存相比而言要比HashMap大，并且性能会差一些，但是如果需要考虑到元素插入的顺序的话，LinkedHashMap是一种较好的选择。

TreeMap底层是红黑树，所以在需要有序map集合时候采用/。



## IO和NIO区别

**面向流和面向缓冲区：**

​	IO是面向流的，NIO是面向缓冲区的。Java IO面向流意味着每次从流中读一个活多个字节，直至读取所有字节，它没有被缓存在任何地方，此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。Java NIO数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是还需要检查是否该缓冲区中包含所有你需要处理的数据。而且，需要确保当更多的数据读取缓冲区时，不能覆盖缓冲区里尚未处理的数据。

**阻塞和非阻塞IO**

​	Java IO的各种流是阻塞的，这意味着，当一个线程调用read()或write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。JavaNIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据。

**选择器**

​	Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。



## String、StringBuffer 和 StringBuilder 的区别是什么? 

String 类中使用 final 关键字修饰字符数组来保存字符串，`private final char value[]`，所以 String 对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串`char[]value` 但是没有用 final 关键字修饰，所以这两种对象都是可变的。

StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的。

**线程安全性**：

String 中的对象是不可变的，也就可以理解为常量，线程安全。

StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。

StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。

**性能**：

每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。

**对于三者使用的总结：**

1. 操作少量的数据: 适用String
2. 单线程操作字符串缓冲区下操作大量数据: 适用StringBuilder
3. 多线程操作字符串缓冲区下操作大量数据: 适用StringBuffer

主要因为StringBuffer很多方法都是synchronized 修饰的。



## 在Java中String是不可变的和无法改变的，有什么好处？

1、可以使用字符串池来存储字符串，提高存储效率。

2、增加安全性，在存储一些敏感信息，如数据库用户名，密码等是，黑客不能改变它的值。java的类加载器加载类时，字符串的不变性可以确保正确的类被加装。

3、由于String是不可变的，它是安全的,在多线程环境下，我们不需要任何同步。



## 生产者消费者模式





## Java反射

Java反射就是指在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。



## final关键

- 修饰数据（成员变量和局部变量）：该变量只能被赋值一次且它的值无法被改变。
  - 用于成员变量来讲，修饰的类变量，必须在声明时初始化；修饰的实例变量，必须在声明时或者构造方法中对它赋值。
- 修饰方法参数：表示在变量的生存期中它的值不能被改变
- 修饰方法：表示该方法无法被重写
- 修饰类：表示该类无法被继承



## ArrayList和LinkedList的大致区别

1. ArrayList是实现了基于动态数组的数据结构，LinkedList是基于链表结构。
2. 对于随机访问的get和set方法，ArrayList要优于LinkedList，因为LinkedList要移动指针。
3. 对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。







#==JVM模块==

## 什么是JVM？

JVM：Java Virtual Machine 是Java的虚拟机，是JRE的一部分。它是整个java实现跨平台的最核心的部分，负责解释执行字节码文件，是可运行java字节码文件的虚拟计算机。

## Java文件的运行？

一个Java文件从编码完成到最终执行，一般主要包括两个过程

- 编译：即把我们写好的java文件，通过javac命令编译成字节码，也就是我们常说的.class文件。
- 运行：则是把编译生成的.class文件交给Java虚拟机(JVM)执行。

而我们所说的类加载过程即是指JVM虚拟机把.class文件中类信息加载进内存，并进行解析生成对应的class对象的过程。

## JVM类加载机制？

虚拟机把描述类的数据从 class 文件加载到内存，并对数据进行校验，解析和初始化。

类加载过程：加载、验证、准备、解析和初始化。

## JVM的内存结构？

java内存通常被划分为5个区域：程序计数器(Program Counter Register)、Java栈(VM Stack)、本地方法栈(Native Method Stack)、方法区(Method Area)、堆(Heap)。

其中堆和方法区是线程共享的部分，其他是线程隔离的。

**堆**：Java中的堆是用来存储对象本身的以及数组（当然，数组引用是存放在Java栈中的）。只不过和C语言中的不同，在Java中，程序员基本不用去关心空间释放的问题，Java的垃圾回收机制会自动进行处理。java堆也是垃圾回收的主要区域。另外，堆是被所有线程共享的，在JVM中只有一个堆。

**方法区**：它与堆一样，是被线程共享的区域。在方法区中，用于存储已被虚拟机加载的类信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。

**Java栈**：也称作虚拟机栈，Java栈是Java方法执行的内存模型。Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法。线程当前执行的方法所对应的栈帧必定位于Java栈的顶部。

**本地方法栈**：本地方法栈与Java栈的作用和原理非常相似。区别是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的。

**程序计数器**：也有称作为PC寄存器。用来指示执行哪条指令的。在JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的地址；如果线程执行的是native方法，则程序计数器中的值是undefined。

## 如何判断对象存活

判断对象常规有两种方法：引用计数算法和可达性分析算法（Reachability Analysis）。

引用计数算法：给对象添加一个引用计数器，每当有一个地方引用它时计数器加1，引用释放时计数减1，当计数器为0时可以回收。

可达性分析算法：基本思想是通过一系列称为“GC Root”的对象（如系统类加载器、栈中的对象、处于激活状态的线程等）作为起点，基于对象引用关系，开始向下搜索，所走过的路径称为引用链，当一个对象到GC Root没有任何引用链相连，证明对象是不可用的。

## JVM垃圾回收算法

**标记-清除：标记存活对象，清理其他垃圾对象。**

- 优点:效率高（只需要把其他位置擦掉）。

- 缺点:产生碎片(碎片导致分配大对象时要整理成连续的)。

**标记-整理：标记之后，把其他垃圾对象清除，整理对象成连续存放。减少磁盘碎片。**

- 优点:没有碎片。

- 缺点:效率低(对象在空间里频繁复制)。

**复制(要有对等内存空间保持为空)：需要两块相等的内存空间，一块内存保存为空。标记存活对象后，直接复制到右边空的内存空间，清空全部左边空间**

- 优点:效率高

- 缺点:浪费内存

## 垃圾回收器

1. Serial收集器

   Serial，是单线程执行垃圾回收的。当需要执行垃圾回收时，程序会暂停一切手上的工作，然后单线程执行垃圾回收。

   因为新生代的特点是对象存活率低，所以收集算法用的是复制算法，把新生代存活对象复制到老年代，复制的内容不多，性能较好。

2. ParNew收集器

   ParNew同样用于新生代，是Serial的多线程版本，并且在参数、算法（同样是复制算法）上也完全和Serial相同。

   因为是多线程执行，所以在多CPU下，ParNew效果通常会比Serial好。但如果是单CPU则会因为线程的切换，性能反而更差。

3. Parallel Scavenge收集器

   新生代的收集器，同样用的是复制算法，也是并行多线程收集。与ParNew最大的不同，它关注的是垃圾回收的吞吐量。

   这里的吞吐量指的是 总时间与垃圾回收时间的比例。这个比例越高，证明垃圾回收占整个程序运行的比例越小。

4. Serial Old收集器

   老年代的收集器，与Serial一样是单线程，不同的是算法用的是标记-整理（Mark-Compact）。

   因为老年代里面对象的存活率高，如果依旧是用复制算法，需要复制的内容较多，性能较差。并且在极端情况下，当存活为100%时，没有办法用复制算法。所以需要用Mark-Compact，以有效地避免这些问题。

5. Parallel Old收集器

   老年代的收集器，是Parallel Scavenge老年代的版本。其中的算法替换成Mark-Compact。

6. CMS收集器

   CMS，Concurrent Mark Sweep，同样是老年代的收集器。它关注的是垃圾回收最短的停顿时间（低停顿），在老年代并不频繁GC的场景下，是比较适用的。

   来看看具体地工作原理。CMS整个过程比之前的收集器要复杂，整个过程分为四步：

   - 初始标记（initial mark），单线程执行，需要“Stop The World”，但仅仅把GC Roots的直接关联可达的对象给标记一下，由于直接关联对象比较小，所以这里的速度非常快。
   - 并发标记（concurrent mark），对于初始标记过程所标记的初始标记对象，进行并发追踪标记，此时其他线程仍可以继续工作。此处时间较长，但不停顿。
   - 重新标记（remark），在并发标记的过程中，由于可能还会产生新的垃圾，所以此时需要重新标记新产生的垃圾。此处执行并行标记，与用户线程不并发，所以依然是“Stop The World”，时间比初始时间要长一点。
   - 并发清除（concurrent sweep），并发清除之前所标记的垃圾。其他用户线程仍可以工作，不需要停顿。

   **有人会觉得既然Mark Sweep会造成内存碎片，那么为什么不把算法换成Mark Compact呢？**

   **答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“Stop the World”这种场景下使用。**

7. G1收集器

   G1，Garbage First，在JDK 1.7版本正式启用，是当时最前沿的垃圾收集器。G1可以说是CMS的终极改进版，解决了CMS内存碎片、更多的内存空间登问题。虽然流程与CMS比较相似，但底层的原理已是完全不同。

   **高效益优先**。G1会预测垃圾回收的停顿时间，原理是计算老年代对象的效益率，优先回收最大效益的对象。

   **堆内存结构的不同**。以前的收集器分代是划分新生代、老年代、持久代等。

   **两种GC模式**：

   - Young GC，关注于所有年轻代的Region，通过控制收集年轻代的Region个数，从而控制GC的回收时间。
   - Mixed GC，关注于所有年轻代的Region，并且加上通过预测计算最大收益的若干个老年代Region。

   整体的执行流程：

   - 初始标记（initial mark），标记了从GC Root开始直接关联可达的对象。STW（Stop the World）执行。
   - 并发标记（concurrent marking），并发标记初始标记的对象，此时用户线程依然可以执行。
   - 最终标记（Remark），STW，标记再并发标记过程中产生的垃圾。
   - 筛选回收（Live Data Counting And Evacuation），评估标记垃圾，根据GC模式回收垃圾。STW执行。

   在Region层面上，整体的算法偏向于Mark-Compact。因为是Compact，会影响用户线程执行，所以回收阶段需要STW执行。

8. ZGC

   在JDK 11当中，加入了实验性质的ZGC。它的回收耗时平均不到2毫秒。它是一款低停顿高并发的收集器。

   ZGC主要新增了两项技术，一个是**着色指针Colored Pointer**，另一个是**读屏障Load Barrier**。

## 类加载器双亲委派模型机制？

当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。

*为什么会有这样的规矩设定？*

> 因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要 ClassLoader 再加载一次。考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String 已经在启动时就被引导类加载器（Bootstrcp ClassLoader）加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变 JDK 中 ClassLoader 搜索类的默认算法。

我们发现除了启动类加载器（BootStrap ClassLoader），每个类都有其"父类"加载器

> ⚠️ 其实这里的父子关系是组合模式，不是继承关系来实现

## 堆里面的分区：Eden，survival （from+ to），老年代，各自的特点？

堆里面分为新生代和老生代（java8 取消了永久代，采用了 Metaspace），新生代包含 Eden+Survivor 区，survivor 区里面分为 from 和 to 区，内存回收时，如果用的是复制算法，从 from 复制到 to，当经过一次或者多次 GC 之后，存活下来的对象会被移动到老年区，当 JVM 内存不够用的时候，会触发 Full GC，清理 JVM 老年区。当新生区满了之后会触发 YGC,先把存活的对象放到其中一个 Survice区，然后进行垃圾清理。因为如果仅仅清理需要删除的对象，这样会导致内存碎片，因此一般会把 Eden 进行完全的清理，然后整理内存。那么下次 GC 的时候，就会使用下一个 Survive，这样循环使用。如果有特别大的对象，新生代放不下，就会使用老年代的担保，直接放到老年代里面。因为 JVM 认为，一般大对象的存活时间一般比较久远。

##java四种引用类型

Java将引用分为了：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4 种，这 4 种引用的强度依次减弱。

#####强引用：

Java中默认声明的就是强引用，只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收。如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为null，这样一来，JVM就可以适时的回收对象了

#####软引用：

软引用是用来描述一些非必需但仍有用的对象。**在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常**。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。

##### 弱引用：

弱引用的引用强度比软引用要更弱一些，**无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收**。

##### 虚引用：

虚引用是所有引用类型中最弱的一个。一个持有虚引用的对象，和没有引用几乎是一样的，随时都可能被垃圾回收器回收。当试图通过虚引用的get()方法取得强引用时，总是会失败。并且，虚引用必须和引用队列一起使用，它的作用在于跟踪垃圾回收过程。 

弱引用与软引用:

1. 这是单纯想解决oom问题的时候,建议用软引用,对于性能比较在意,想回收占内存比较大的对象,用弱引用

2. 可以根据对象是否经常使用来判断。如果该对象可能会经常使用的，就尽量用软引用。如果该对象不被使用的可能性更大些，就可以用弱引用